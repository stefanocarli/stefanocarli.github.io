---
layout: post
title: "Decodifica del malware PHP Filesman"
author: "stef"
categories: malware
tags: [documentation,sample]
image: assets/images/malware-cartoon.jpg
  feature: malware-cartoon.jpg
  teaser: malware-cartoon.jpg
  credit:
  creditlink:
---

Recentemente mi è capitato di leggere [questa](http://stackoverflow.com/questions/25993817/strange-code-on-wordpress-website) domanda fatta su [stackoverflow.com](http://stackoverflow.com/) nella quale un utente, trovando in un file php del proprio sito Wordpress del codice particolare, ne chiede il significato. 

>Today I checked my wordpress website and I observed that one php file had the following code in it: According to [THIS](http://www.unphp.net/decode/0ab3310454272a9d776c468f6f8a5ef8/) it is a encode(eval64)) hack. What's the meaning of the code below? Is this the same as the base encode eval64 hack?

In questo articolo proverò ad analizzare il codice dato, che per completezza riporto anche su [pastebin](http://pastebin.com/1d7p3Cyx).

### 1. Scopo e metodologia utilizzata

Proviamo a tradurre il codice in modo da renderlo leggibile o utilizzabile in modo da capirne lo scopo. Per fare questo porterò avanti un'azione di decodifica suddivisa in passi successivi che chiamerò _stage_. Per ogni passo costruirò un diagramma che permetterà di tenere traccia delle azioni effettuate. Di seguito un diagramma della la situazione iniziale: 

[![Stage0](http://stefano.chebravo.com/wp-content/uploads/2015/05/Stage0.png)](http://stefano.chebravo.com/wp-content/uploads/2015/05/Stage0.png) 

**Legenda**

*   In <span style="color: #008000;">verde</span> la parte di codice che non deve essere decodificata e che presumibilmente serve per il vero e proprio funzionamento del codice finale.
*   In <span style="color: #ffcc99;">giallo</span> indico la parte di codice che non sembra debba essere codificata ma di cui non è ancora chiaro lo scopo oppure che verrà richiamata durante le fasi di decodifica ma che probabilmente non servirà una volta che il codice sarà completamente decodificato.
*   In <span style="color: #ff0000;">rosso</span> le parti che devono essere chiaramente decodificate.
*   In <span style="color: #3366ff;">blu</span> le parti di codice che presentano funzioni comandi o costrutti che sono mere parti del processo di decodifica.


### 2. Analisi preliminare del codice

```PHP
<?
$auth_pass = "2fba9596aec8aeb14a88461bbd708f97";
$color = "#df5";
$default_action = 'FilesMan';
$default_use_ajax = true;
$default_charset = 'Windows-1251';

$xYEzDu6r3EZT="Lunga variabile";
eval(base64_decode("Codice offuscato"));
return;
?>
```

Il codice contiene sei variabili ed un comando _eval_. Possiamo fare subito alcune considerazioni:

*   Le prime 5 variabili sono chiaramente leggibili
    *   la prima variabile sembra essere una codifica md5 o similare.
    *   la dicitura "FilesMan" è tipica del backdoor chiamato FilesMan che si è diffuso tempo fa.
    *   [Windows-1251](http://en.wikipedia.org/wiki/Windows-1251) è un tipo di codifica.
    *   probabilmente le 5 variabili risulteranno essere utili successivamente una volta decodificato il codice. Per noi ora non hanno utilità.
*   La variabile _$xYEzDu6r3EXT_ ha come valore una stringa estremamente lunga. Probabilmente verrà richiamata successivamente nel codice per essere in qualche modo decodificata ed utilizzata in passi successivi.
*   La parte pericolosa del codice, quella che in questa fase viene utilizzata come un vero e proprio innesco, è il comando _[eval](http://php.net/manual/it/function.eval.php)_.
    *   Il comando eval valuta una stringa come codice PHP. In questo caso esegue la funzione _[base64_decode](http://php.net/manual/it/function.base64-decode.php)_, che decodifica da base64 la stringa che gli viene data come parametro.

### 3. Decodifica del codice

#### 3.1 Stage 1: eval e base64_decode

In modo da avere in output la decodifica del codice offuscato, sostituiamo ad _eval_ il comando _echo_, come nel seguente esempio:

``` php
echo base64_decode("Codice offuscato");
```

Il codice decodificato restituisce _due nuovi comandi eval(base64_decode("Stringa"))_, segnalati in viola nell'immagine di seguito (cliccare sull'immagine per ingrandirla). Si tratta quindi di codice codificato in base64 più e più volte in modo da risultare quanto meno riconoscibile possibile. [![FilesMan-Decode-Step01](http://stefano.chebravo.com/wp-content/uploads/2015/05/FilesMan-Decode-Step01.png)](http://stefano.chebravo.com/wp-content/uploads/2015/05/FilesMan-Decode-Step01.png) Aggiungiamo al diagramma di partenza il primo passo di decodifica eseguito. Si vede chiaramente come, da una prima espressione da valutare, ne nascano altre due. È da subito evidente come siano state applicate metodologie di offuscamento sul codice originale più e più volte, nel tentativo di renderlo difficilmente leggibile. Armiamoci di pazienza perché probabilmente la decodifica richiederà molti di questi passi. 
[![Stage1](http://stefano.chebravo.com/wp-content/uploads/2015/05/Stage1.png)](http://stefano.chebravo.com/wp-content/uploads/2015/05/Stage1.png)

#### 3.2 Stage 2

Valutiamo le due espressioni appena trovate: Valutando la prima troviamo due nuove espressioni _eval(base64_decode("Stringa"))_ [![FilesMan-Decode-Step02](http://stefano.chebravo.com/wp-content/uploads/2015/05/FilesMan-Decode-Step02.png)](http://stefano.chebravo.com/wp-content/uploads/2015/05/FilesMan-Decode-Step02.png) Valutando la seconda espressione otteniamo finalmente qualcosa di più comprensibile. [![FilesMan-Decode-Step03](http://stefano.chebravo.com/wp-content/uploads/2015/05/FilesMan-Decode-Step03.png)](http://stefano.chebravo.com/wp-content/uploads/2015/05/FilesMan-Decode-Step03.png) Il risultato è un ciclo _for_, oltre all'espressione di innesco _eval_. Possiamo riscrivere questa porzione di codice indentandolo correttamente. [![FilesMan-Decode-Step04](http://stefano.chebravo.com/wp-content/uploads/2015/05/FilesMan-Decode-Step04.png)](http://stefano.chebravo.com/wp-content/uploads/2015/05/FilesMan-Decode-Step04.png) La variabile _$xltUlCb5Gxs_ è il contatore del ciclo. Per rendere il codice più leggibile possiamo indicarla con _$i_. Le variabili _$x7st79VVrvR_ e _$xWxG9z44O0p_ hanno ancora un valore sconosciuto, in quanto nel nostro lavoro di decodifica non le abbiamo ancora incontrate. La variabile _$xYEzDu6r3EZT_ è quella variabile a noi nota fin dall'inizio, che abbiamo indicato come "_lunga variabile_". 
![Stage2](http://stefano.chebravo.com/wp-content/uploads/2015/05/Stage21.png)

#### 3.3 Stage 3

Il primo _eval_ diventa [![FilesMan-Decode-Step05](http://stefano.chebravo.com/wp-content/uploads/2015/05/FilesMan-Decode-Step05.png)](http://stefano.chebravo.com/wp-content/uploads/2015/05/FilesMan-Decode-Step05.png) Il secondo _eval_ diventa [![FilesMan-Decode-Step05-1](http://stefano.chebravo.com/wp-content/uploads/2015/05/FilesMan-Decode-Step05-1.png)](http://stefano.chebravo.com/wp-content/uploads/2015/05/FilesMan-Decode-Step05-1.png) Il ciclo _for_ diventa [![FilesMan-Decode-Step05-2](http://stefano.chebravo.com/wp-content/uploads/2015/05/FilesMan-Decode-Step05-2.png)](http://stefano.chebravo.com/wp-content/uploads/2015/05/FilesMan-Decode-Step05-1.png) La situazione attuale 
[![Stage3](http://stefano.chebravo.com/wp-content/uploads/2015/05/Stage3-1024x508.png)](http://stefano.chebravo.com/wp-content/uploads/2015/05/Stage3.png) 

#### 3.4 Stage 4: il ciclo _for_

A questo punto la situazione va delineandosi. La chiave di volta del codice è in questo momento il ciclo _for_. Per capire cosa il ciclo produce proviamo a valutarlo. Lo facciamo riprendendo la variabile _$xYEzDu6r3EZT_, decodificandola in base64, trovandone la lunghezza e sostituendo i valori trovati all'interno del ciclo for dove opportuno. Al solito la _eval_ diventa echo per valutare l'output prodotto dal ciclo; tale output è parzialmente visibile nella parte bassa della figura. [![FilesMan-Decode-Step06](http://stefano.chebravo.com/wp-content/uploads/2015/05/FilesMan-Decode-Step06.png)](http://stefano.chebravo.com/wp-content/uploads/2015/05/FilesMan-Decode-Step06.png) Per maggiore chiarezza indico l'output di seguito: [![FilesMan-Decode-Step07](http://stefano.chebravo.com/wp-content/uploads/2015/05/FilesMan-Decode-Step07.png)](http://stefano.chebravo.com/wp-content/uploads/2015/05/FilesMan-Decode-Step07.png) l'ultima parte del diagramma [caption id="attachment_497" align="alignnone" width="669"][![Stage4](http://stefano.chebravo.com/wp-content/uploads/2015/05/Stage4.png)](http://stefano.chebravo.com/wp-content/uploads/2015/05/Stage4.png) Diagramma: Fase 4[/caption]  

#### 3.5 Stage 5: gli ultimi passi

Dovremmo finalmente essere vicini alla soluzione. Proviamo a valutare la funzione _solidstate_, in modo da farci ritornare la variabile _$lol._ [![FilesMan-Decode-Step08](http://stefano.chebravo.com/wp-content/uploads/2015/05/FilesMan-Decode-Step08.png)](http://stefano.chebravo.com/wp-content/uploads/2015/05/FilesMan-Decode-Step08.png) La funzione ritorna di nuovo un codice da decodificare. È interessante notare come questa volta non si utilizzi _eval_ come innesco, ma la funzione _preg_replace_ con il [modificatore di criterio](http://php.net/manual/it/reference.pcre.pattern.modifiers.php) **e**. Ne ho già parlato in un mio [precedente articolo](http://stefano.chebravo.com/it/decodificare-malware-php/).

#### 3.6 Stage 6: eval, gzinflate e base64_decode

Valutiamo quindi il contenuto di _$source_ e ne otteniamo una nuova espressione _eval_. [![FilesMan-Decode-Step09](http://stefano.chebravo.com/wp-content/uploads/2015/05/FilesMan-Decode-Step09.png)](http://stefano.chebravo.com/wp-content/uploads/2015/05/FilesMan-Decode-Step09.png)  

#### 3.7 Stage 7: il codice finale

Come ormai di consueto valutiamo l'espressione. Finalmente siamo arrivati alla fine. Davanti a noi il codice in chiaro! [![FilesMan-Decode-Step10](http://stefano.chebravo.com/wp-content/uploads/2015/05/FilesMan-Decode-Step10.png)](http://stefano.chebravo.com/wp-content/uploads/2015/05/FilesMan-Decode-Step10.png) Di seguito il diagramma completo [caption id="attachment_503" align="alignnone" width="1024"][![FilesMan](http://stefano.chebravo.com/wp-content/uploads/2015/05/FilesMan-1024x253.png)](http://stefano.chebravo.com/wp-content/uploads/2015/05/FilesMan.png) Diagramma completo[/caption] [hr]

### 4. Che cosa fa?

È stato indubbiamente un lungo viaggio. A questo punto vogliamo ovviamente sapere cosa fa questo codice. Essendo semplice codice PHP creiamo una pagina ad hoc, e visualizziamolo nel nostro browser.

[![FilesMen-usage](http://stefano.chebravo.com/wp-content/uploads/2015/05/FilesMon-usage-1024x418.png)](http://stefano.chebravo.com/wp-content/uploads/2015/05/FilesMon-usage.png)

Notiamo che la backdoor è molto completa. Ha un file manager, una console, un SQL browser, un interprete PHP e molto altro.
[![FilesMen-usage1](http://stefano.chebravo.com/wp-content/uploads/2015/05/FilesMon-usage1.png)](http://stefano.chebravo.com/wp-content/uploads/2015/05/FilesMon-usage1.png)
Molto interessante è la possibilità di convertire le stringe in una vasta quantità di formati, cercare file sul computer o hash su internet. Degni di nota sono anche lo strumento di bruteforce, quello di rete e l'auto-rimozione del codice malevolo.
